<!--
ISC License

Copyright (c) 2021, Tromgy (tromgy@yahoo.com)

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/npm-tree.ico" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="apple-touch-icon" href="/npm-tree.png" />
    <title>npm-tree</title>
    <style>
      :root {
        --dark-background: rgb(3, 44, 54);
        --drop-zone: rgb(250, 250, 250);
        --error: rgb(243, 67, 54);
        --bright-stroke: rgb(255, 255, 255);
        --default-button: rgb(54, 76, 89);
        --default-stroke: rgb(226, 232, 237);
        --focused-button: rgb(44, 64, 76);
        --pressed-button: rgb(12, 20, 25);
        --default-text: rgb(168, 196, 214);
        --tree-expander: rgb(20, 121, 201);
        --main-text: rgb(0, 0, 0);
        --version-text: rgb(127, 174, 27);
        --highlight: rgb(255, 244, 112);
        --medium-background: rgb(168, 196, 214);
        --de-emphasize: rgb(136, 154, 165);
        --drop-zone-shade: rgba(0, 0, 0, 0.6);
        --wait-shade: rgb(0, 0, 0, 0.2);
        --monospace-font: Menlo, Monaco, Consolas, "Courier New", monospace;
        --sans-font: Nunito, Helvetica, Arial, sans-serif;
        --round-corner: 6px;
        --button-padding: 8px;
      }

      body {
        margin: 0;
        overflow: hidden;
      }

      header {
        background-color: var(--dark-background);
        color: var(--bright-foreground);
        padding: 10px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
      }

      div {
        display: inline-flex;
        align-items: center;
      }

      button {
        background: var(--default-button);
        border: none;
        padding: var(--button-padding);
        margin: 6px;
        border-radius: var(--round-corner);
        outline: none;
        color: var(--bright-foreground);
        cursor: pointer;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        stroke: var(--default-stroke);
      }

      button:hover,
      button:focus {
        background-color: var(--focused-button);
        stroke: var(--bright-stroke);
      }

      button:active {
        background-color: var(--pressed-button);
        stroke: var(--bright-stroke);
      }

      #title {
        font-family: var(--monospace-font);
        font-size: 24px;
        color: var(--bright-stroke);
        white-space: nowrap;
      }

      input {
        border: none;
        padding-left: 40px;
        padding-top: 8px;
        padding-bottom: 8px;
        padding-right: 16px;
        border-radius: var(--round-corner);
        margin: 6px;
        line-height: 25px;
      }

      input:focus {
        outline: none;
      }

      svg {
        height: 25px;
        width: 25px;
        stroke: inherit;
        stroke-width: 20px;
        stroke-linecap: round;
        fill: none;
      }

      svg.logo {
        height: 40px;
        width: 40px;
        padding-right: 20px;
      }

      #search-container {
        position: relative;
      }

      #whole-word-search {
        position: absolute;
        left: 15px;
        stroke: var(--default-button);
        fill: var(--default-button);
        cursor: pointer;
      }

      .pressed {
        background-color: var(--default-stroke);
      }

      main {
        height: calc(100vh - 110px);
        overflow: auto;
      }

      ul {
        font-family: var(--monospace-font);
        list-style-type: none;
        color: var(--default-text);
      }

      .hidden {
        display: none;
      }

      .shown {
        display: block;
      }

      .bullet {
        color: var(--tree-expander);
        cursor: pointer;
      }

      .dependency {
        color: var(--main-text);
        cursor: pointer;
      }

      .unmet-dependency {
        color: var(--error);
      }

      .version {
        color: var(--version-text);
      }

      .selected {
        font-weight: bold;
        background-color: var(--highlight);
      }

      footer {
        background-color: var(--medium-background);
        padding: 10px;
        font-family: var(--monospace-font);
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      .path-separator {
        font-weight: lighter;
        color: var(--de-emphasize);
      }

      .wait-shade {
        position: fixed;
        left: 0;
        top: 0;
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw;
        background: var(--wait-shade);
      }

      .wait-shade.hidden {
        display: none;
      }
      #drop-modal {
        display: block;
        position: fixed;
        left: 0;
        top: 0;
        z-index: 9999;
        width: 100%;
        height: 100%;
        padding-top: 200px;
        background-color: var(--drop-zone-shade);
        overflow: auto;
        opacity: 1;
        transition: all 0.7s ease-out;
      }

      #drop-modal.hidden {
        opacity: 0;
        visibility: hidden;
      }

      .drop-zone {
        background-color: var(--drop-zone);
        margin: auto;
        padding: 20px;
        border-radius: 24px;
        max-width: 300px;
        border: 2px var(--tree-expander) dashed;
        font-family: var(--sans-font);
        text-align: center;
        cursor: pointer;
      }

      .drop-error {
        background-color: var(--error);
        color: var(--bright-stroke);
        margin: auto;
        padding: 5px 15px;
        border-radius: 24px;
        max-width: 300px;
        border: 2px var(--bright-stroke) solid;
        font-family: var(--sans-font);
        cursor: pointer;
      }

      .close {
        font-size: 32px;
      }
    </style>
  </head>

  <body>
    <div id="drop-modal">
      <div
        class="drop-zone shown"
        id="drop-zone"
        ondrop="dropOver(event)"
        ondragover="dragOver(event)"
        onclick="triggerGetFile()"
      >
        <section>
          <p>Drag a file containing output from</p>
          <pre>npm list --all</pre>
          <p>and drop it here, or click to choose the file.</p>

          <p><small>Your file stays in the browser.</small></p>

          <input
            id="browse-files"
            type="file"
            onchange="getFile(this)"
            hidden
          />
        </section>
      </div>
      <div class="drop-error hidden" id="drop-error">
        <section>
          <div class="close" onclick="closeErrorMessage()">&times;</div>
          <p>
            Could not process your file. Please make sure it was generated by
          </p>
          <pre>npm list --all</pre>
          <p>and try again.</p>
        </section>
      </div>
    </div>

    <header>
      <div>
        <button onclick="collapseAll(false)" title="Expand all" tabindex="1">
          <svg viewBox="0 0 500 500">
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.1"
              y1="89.1"
              x2="255.1"
              y2="89.1"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="178.9"
              y1="205.3"
              x2="327.9"
              y2="205.3"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="179.3"
              y1="147.2"
              x2="328.4"
              y2="147.2"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="178.9"
              y1="321.5"
              x2="327.9"
              y2="321.5"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="178.9"
              y1="379.6"
              x2="327.9"
              y2="379.6"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="32.835"
              y1="30.979"
              x2="289.621"
              y2="30.979"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.1"
              y1="263.541"
              x2="255.1"
              y2="263.541"
            />
            <line x1="490" y1="490" x2="395.924" y2="395.924" />
            <line x1="490" y1="411.626" x2="490" y2="490" />
            <line x1="411.6" y1="490" x2="490" y2="490" />
          </svg>
        </button>
        <button onclick="collapseAll(true)" title="Collapse all" tabindex="2">
          <svg viewBox="0 0 500 500">
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="89.088"
              x2="255.145"
              y2="89.088"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="205.307"
              x2="255.145"
              y2="205.307"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="147.198"
              x2="255.145"
              y2="147.198"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="263.417"
              x2="255.145"
              y2="263.417"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="321.526"
              x2="255.145"
              y2="321.526"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="32.835"
              y1="30.979"
              x2="289.621"
              y2="30.979"
            />
            <line
              style="stroke-dasharray: 30px; stroke-dashoffset: 7px"
              x1="106.142"
              y1="379.636"
              x2="255.145"
              y2="379.636"
            />
            <g transform="matrix(1, 0, 0, 1, -11.220118, -11.77985)">
              <line
                x1="500"
                y1="500"
                x2="405.9"
                y2="405.9"
                transform="matrix(-1, 0, 0, -1, 905.899994, 905.899994)"
              />
              <line
                x1="405.924"
                y1="405.924"
                x2="405.924"
                y2="484.298"
                transform="matrix(-1, 0, 0, -1, 811.848022, 890.222015)"
              />
              <line
                x1="405.924"
                y1="405.924"
                x2="484.324"
                y2="405.924"
                transform="matrix(-1, 0, 0, -1, 890.248016, 811.848022)"
              />
            </g>
          </svg>
        </button>
      </div>
      <div id="title">
        <svg class="logo" viewBox="0 0 564.28 670.9">
          <defs>
            <style>
              .cls-1 {
                fill: #c7b299;
              }

              .cls-2 {
                fill: #39b54a;
              }

              .cls-3 {
                fill: none;
                stroke: #fff;
                stroke-linecap: round;
                stroke-dashoffset: 7px;
                stroke-width: 10px;
                stroke-dasharray: 20 15 15 15 20;
              }
            </style>
          </defs>
          <g id="base_tree" data-name="base tree">
            <path
              class="cls-1"
              d="M554.54,722.23c0-41.57.62-81.65,1.27-131.19-15.24.59-30.48,1.27-45.72,1.64C501.94,770,475,875.91,400.16,921c77.4-6.57,176.7-11.52,229.93-13.64C591.05,878.26,554.54,825.4,554.54,722.23Z"
              transform="translate(-229.97 -250.13)"
            />
            <path
              class="cls-2"
              d="M527.71,603.09c-15.13,23.44-48.6,37.09-79.66,37.09-43.71,0-51-22.65-71.28-32.47-19-9.21-36.75-7-54.13-24.34-12.86-12.8-11.66-34.39-23.48-46-16.1-15.78-48.56-14-48.56-54,0-9.68,1.74-19.53,1.74-28.82,0-35.79-22.37-14.21-22.37-67.77,0-32.55,23.09-35.88,37.66-45.49,22-14.56,40.6-47.44,66-47.44,8,0,16.65,3.24,26.31,11.29,29-6.37,48-25.9,70.72-25.9,9.62,0,19.91,3.5,31.91,13,12.9-25.26,51.78-42.11,85.94-42.11,18.27,0,35.19,4.82,46.07,15.74,35.44.9,149.93,44.14,149.93,79.28,0,11.12-10.07,30-11.86,40.1,19.63,15,53.49,11.11,53.49,50.84,0,24.32-19.35,35.42-19.63,43,19.83,9.62,27.69,21.86,27.69,34,0,23-27.91,45.74-56.3,50.54A50.63,50.63,0,0,1,740.18,578c0,24.4-22.39,35.44-45.81,35.44-14.61,0-29.62-4.29-39.87-12.32-22,4.12-20.74,35.78-61.21,35.78-26.82,0-55.95-16.52-65.58-33.79"
              transform="translate(-229.97 -250.13)"
            />
          </g>
          <g id="symbolic_tree" data-name="symbolic tree">
            <line class="cls-3" x1="238.02" y1="126.4" x2="326.03" y2="126.4" />
            <line
              class="cls-3"
              x1="281.02"
              y1="195.03"
              x2="369.03"
              y2="195.03"
            />
            <line
              class="cls-3"
              x1="281.26"
              y1="160.71"
              x2="369.32"
              y2="160.71"
            />
            <line
              class="cls-3"
              x1="281.02"
              y1="263.67"
              x2="369.03"
              y2="263.67"
            />
            <line
              class="cls-3"
              x1="281.02"
              y1="297.98"
              x2="369.03"
              y2="297.98"
            />
            <line class="cls-3" x1="194.75" y1="92.07" x2="346.42" y2="92.07" />
            <line
              class="cls-3"
              x1="238.02"
              y1="229.43"
              x2="326.03"
              y2="229.43"
            />
          </g>
        </svg>
        npm-tree
      </div>
      <div>
        <div id="search-container">
          <svg
            id="whole-word-search"
            width="500"
            height="500"
            viewBox="0 0 500 500"
            onclick="toggleSearchMode()"
          >
            <line x1="34.98" y1="131.38" x2="35" y2="368.6" />
            <line x1="465" y1="131.4" x2="465" y2="368.6" />
            <g style="stroke-width: 0px">
              <path
                d="M168.94,253.56v65.53c-19.33-.48-20.05,4.85-19-17C80.82,376,20.06,229.54,150,246.6c3.81-38.95-44.87-32.18-67.58-18.26-1.93-20.05,1.16-21.27,20-24.87C138.35,194.4,174.67,211.84,168.94,253.56Zm-36.6,7.8c-38.93-1.82-58.74,41.07-15.9,44.91,24.74.23,34.75-21.52,33.53-44.91C150,261.36,147.9,262.08,132.34,261.36Z"
              />
              <path
                d="M225.44,218.91c28.55-41.74,72.74-2.58,72.18,42.87-.57,46.26-43.12,84.94-72.18,42.85,1.74,20.89-2.72,13.1-18.87,14.46V159.54h18.87Zm55.48,42.86c.3-58.56-55.79-58.37-55.48,0S280.61,320.44,280.92,261.77Z"
              />
              <path
                d="M422,313.24c-89.48,51.95-130.31-109.93-32.09-111.77,21.16,1.45,36.64,3.56,32.09,28.61a51.33,51.33,0,0,0-15-9.64c-86.85-26.22-59.17,134,15,73.22Z"
              />
            </g>
            <title>Match whole word only</title>
          </svg>

          <input
            id="search"
            type="search"
            placeholder="🔍"
            oninput="find()"
            title="You can search using string literals or JavaScript regular expressions"
            tabindex="3"
          />
        </div>
        <button onclick="findNext()" title="Find next" tabindex="4">
          <svg viewBox="0 0 500 500">
            <path
              d="M 250 -371.244 L 390 -128.757 L 110 -128.757 L 250 -371.244 Z"
              transform="matrix(1, 0, 0, -1, 0, 0)"
            />
          </svg>
        </button>
        <button onclick="findPrev()" title="Find previous" tabindex="5">
          <svg viewBox="0 0 500 500">
            <path
              d="M 250 128.757 L 390 371.244 L 110 371.244 L 250 128.757 Z"
            />
          </svg>
        </button>
      </div>
    </header>
    <div id="wait-shade" class="wait-shade hidden"></div>
    <main id="tree" onclick="clearSelected(lastSelectedDependency)"></main>
    <footer id="path">&nbsp;</footer>

    <script>
      const dependencies = document.getElementsByClassName("dependency");
      const search = document.getElementById("search");
      const wholeWordSearchButton = document.getElementById(
        "whole-word-search"
      );
      const waitShade = document.getElementById("wait-shade");
      const treeContainer = document.getElementById("tree");
      const path = document.getElementById("path");
      const foundDependencies = [];
      let lastFoundIndex = -1;
      let lastFoundDependency = null;
      let lastSelectedDependency = null;
      const dependencyPath = [];
      let timer = null;
      let wholeWordSearch = false;

      /**
       * Show the element as block
       *
       * @param {Element} element - the Element to change visibility of
       */
      function display(element) {
        element.classList.remove("hidden");
        element.classList.add("shown");
      }

      /**
       * Hide the element from view
       *
       * @param {Element} element
       */
      function hide(element) {
        element.classList.remove("shown");
        element.classList.add("hidden");
      }

      /**
       * Toggles visibility of the tree items below the given tree node.
       *
       * @param {Element} element - the Element that was the source of the event
       */
      function toggleChildrenOf(element) {
        if (element) {
          const arrow = element.innerHTML;

          if (arrow === "▶︎") {
            showChildrenOf(element.parentElement);
          } else {
            hideChildrenOf(element.parentElement);
          }
        }
      }

      /**
       * Hides the tree nodes below the give node.
       *
       * @param {Element} element - the Element representing the tree node to hide the children of
       */
      function hideChildrenOf(element) {
        // The children are not really children
        const deps = element?.nextElementSibling?.children;

        if (deps) {
          for (let i = 0; i < deps.length; i++) {
            const dep = deps.item(i);

            hide(dep);
          }
        }

        const btn = element?.firstElementChild;

        if (btn) {
          btn.textContent = "▶︎";
        }
      }

      /**
       * Shows the tree nodes below the give node.
       *
       * @param {Element} element - the Element representing the tree node to show the children of
       */
      function showChildrenOf(element) {
        // The children are not really children
        const deps = element?.nextElementSibling?.children;

        if (deps) {
          for (let i = 0; i < deps.length; i++) {
            const dep = deps.item(i);

            display(dep);
          }
        }

        const btn = element?.firstElementChild;

        if (btn) {
          btn.textContent = "▼";
        }
      }

      /**
       * Yields control to JavaScript event loop by asynchronosly resolving a promise
       *
       * @returns {Promise} - an empty promise to await for
       */
      function ytel() {
        return new Promise((resolve, _) =>
          setTimeout(() => {
            resolve();
          }, 0)
        );
      }

      /**
       * Collapses or expands the whole tree.
       *
       * @param {boolean} collapse - flag indicating wheter to collapse or expand the tree
       */
      async function collapseAll(collapse) {
        const sizeToDisplayShade = 1000;
        const collapsibles = document.getElementsByClassName("collapsible");
        const numCollapsibles = collapsibles.length;

        if (numCollapsibles > sizeToDisplayShade) {
          display(waitShade);

          // Need to yield before going into the loop to let the browser render the shade
          await ytel();
        }

        for (let i = 0; i < numCollapsibles; i++) {
          const collapsible = collapsibles[i];

          if (collapse) {
            hideChildrenOf(collapsible);
          } else {
            showChildrenOf(collapsible);
          }
        }

        if (numCollapsibles > sizeToDisplayShade) {
          hide(waitShade);
        }
      }

      /**
       * Toggles whole-word search mode.
       */
      function toggleSearchMode() {
        wholeWordSearch = !wholeWordSearch;

        if (wholeWordSearch) {
          wholeWordSearchButton.classList.add("pressed");
        } else {
          wholeWordSearchButton.classList.remove("pressed");
        }

        findAll();
        findNext();
      }

      /**
       * Triggers the search on changes in the search input field.
       * It uses debouncing to run the search only after some time of user inactivity.
       */
      function find() {
        // Wait for that many milliseconds after typing stops
        const inactivityIntervalBeforeSearch = 500;

        if (timer) {
          clearTimeout(timer);
          timer = null;
        }

        timer = setTimeout(() => {
          findAll();
          findNext();
        }, inactivityIntervalBeforeSearch);
      }

      /**
       * The actual search function.
       */
      function findAll() {
        const searchStr = search.value;

        foundDependencies.length = 0;
        lastFoundIndex = -1;

        if (searchStr) {
          const searchExpr = new RegExp(searchStr);

          for (let i = 0; i < dependencies.length; i++) {
            const dependency = dependencies.item(i);

            const match = wholeWordSearch
              ? dependency.textContent === searchStr
              : dependency.textContent.match(searchExpr);

            if (match) {
              foundDependencies.push(dependency);
            }
          }
        }
      }

      /**
       * Moves the selection to the next found instance matching the search expression.
       */
      function findNext() {
        clearFound();

        if (lastFoundIndex === foundDependencies.length - 1) {
          lastFoundIndex = -1;
        }

        lastFoundDependency = foundDependencies[++lastFoundIndex];

        highlightFound();
      }

      /**
       * Moves the selection to the previous found instance matching the search expression.
       */
      function findPrev() {
        clearFound();

        if (lastFoundIndex === 0) {
          lastFoundIndex = foundDependencies.length;
        }

        lastFoundDependency = foundDependencies[--lastFoundIndex];

        highlightFound();
      }

      /**
       * Visually selects the found instance.
       */
      function highlightFound() {
        if (lastFoundDependency) {
          highlightAndPathify(lastFoundDependency, true);
          lastFoundDependency.scrollIntoView({ block: "nearest" });
        }
      }

      /**
       * Visually selects the given tree node, builds up the path from the root, and optionally expands the
       * tree branches leading to this node.
       *
       * @param {Element} dependency - the Element that will be visually selected
       * @param {boolean} expand - the flag specifying whether to expand the tree branch(es)
       */
      function highlightAndPathify(dependency, expand) {
        dependency.classList.add("selected");

        recurseParents(dependency, expand);

        path.innerHTML = dependencyPath.join(
          '<span class="path-separator">&nbsp;▷&nbsp;</span>'
        );
        path.title = dependencyPath.join(" > ");
      }

      /**
       * Recurses the tree up to the root from the given node, building up the path, and optionally expands the
       * tree branches along the way.
       *
       * @param {Element} dependency - the Element that will be visually selected
       * @param {boolean} expand - the flag specifying whether to expand the tree branch(es)
       */
      function recurseParents(dependency, expand) {
        if (dependency.tagName === "LI") {
          // Get the actual dependency name
          dependencyPath.unshift(
            dependency.getElementsByClassName("dependency")[0].innerHTML
          );

          // Get the collapsible element (if any)
          const collapsibles = dependency.getElementsByClassName("collapsible");

          if (collapsibles && expand) {
            showChildrenOf(collapsibles[0]);
          }
        }

        const parent = dependency.parentElement;

        if (parent && parent.tagName !== "MAIN") {
          recurseParents(parent, expand);
        }
      }

      /**
       * Clears all visual selection.
       */
      function clearFound() {
        clearSelected(lastFoundDependency);
        clearSelected(lastSelectedDependency);
      }

      /**
       * Clears visual selection from the given tree node.
       *
       * @param {Element} dependency - the Element that was visually selected
       */
      function clearSelected(dependency) {
        if (dependency) {
          dependency.classList.remove("selected");
          dependencyPath.length = 0;
          path.innerHTML = "&nbsp;";
          path.removeAttribute("title");
        }
      }

      /**
       * Click event handler that visually selects the given tree node.
       *
       * @param {Element} dependency - the Element representing the tree node to select
       * @param {Event} e - click event
       */
      function select(dependency, e) {
        clearFound();
        highlightAndPathify(dependency, false);
        lastSelectedDependency = dependency;
        e.stopPropagation();
      }

      const dropModal = document.getElementById("drop-modal");
      const dropZone = document.getElementById("drop-zone");
      const dropError = document.getElementById("drop-error");
      const fileInput = document.getElementById("browse-files");

      /**
       * Processes file drop.
       *
       * @param {Event} e - the drop event
       */
      function dropOver(e) {
        e.preventDefault();

        if (e.dataTransfer.items) {
          if (e.dataTransfer.items[0].kind === "file") {
            const file = e.dataTransfer.items[0].getAsFile();
            generateTreeFrom(file);
          } else {
            console.warn("not a file");
          }
        }
      }

      /**
       * Processes the drag event.
       *
       * @param {Event} e - the drag event
       */
      function dragOver(e) {
        // Prevent the browser from simply opening the file
        e.preventDefault();
      }

      /**
       * Simulates the click on the invisible file input element.
       */
      function triggerGetFile() {
        fileInput.click();
      }

      /**
       * Receives the File object from the file input element.
       *
       * @param {Element} input - the file input element.
       */
      function getFile(input) {
        const file = input.files[0];
        generateTreeFrom(file);
      }

      /**
       * Processes the file content to generate the dependency tree.
       *
       * @param {File} file - the File object
       */
      function generateTreeFrom(file) {
        file.text().then((content) => {
          try {
            const genHTML = processList(content);
            treeContainer.innerHTML = genHTML;
            dropModal.classList.add("hidden");
          } catch (err) {
            hide(dropZone);
            display(dropError);
          } finally {
            fileInput.value = "";
          }
        });
      }

      function closeErrorMessage() {
        hide(dropError);
        display(dropZone);
      }

      /**
       * Generates HTML-formatted entry for the tree node
       *
       * @param {string} rawEntry - dependency as "name@version extra"
       *
       * @returns {string} the same entry formatted as HTML
       */
      function formatTreeNode(rawEntry) {
        const tokens = rawEntry.split(/@| /);
        let dependency = "";
        let version = "";
        let prefix = "";
        let index = 0;
        let offset = 0;

        for (let i = 0; i < tokens.length; i++) {
          token = tokens[i];

          if (token === "UNMET" || token === "PEER" || token === "DEPENDENCY") {
            prefix += token;
            prefix += " ";
            offset++;
          }
        }

        if (prefix) {
          prefix = `<span class="unmet-dependency">${prefix}</span>`;
        }

        // Only replace @ separating version
        if (rawEntry.startsWith("@")) {
          dependency = `@${tokens[offset + 1]}`;
          version = tokens[offset + 2];
          index = offset + 3;
        } else {
          dependency = tokens[offset];
          version = tokens[offset + 1];
          index = offset + 2;
        }

        return `${prefix}<span class="dependency" onclick="select(this, event)">${dependency}</span> <span class="version">${version}</span> ${tokens
          .slice(index)
          .join(" ")}`;
      }

      /**
       * Converts output from 'npm list' to HTML tree
       *
       * @param {string} input - text output from npm list
       *
       * @returns {string} HTML representing npm dependencies as a collapsible tree
       */
      function processList(input) {
        const lines = input.split("\n");

        // Verify input -- must end with `-- (npm < 7) or └── (npm >= 7)
        // npm list output has always 2 new lines at the end, hence offset by 3
        const lastLine = lines[lines.length - 3].trimStart();
        const validInput =
          lastLine.startsWith("`-") || lastLine.startsWith("└─");

        if (!validInput) {
          throw new Error("Invalid file format");
        }

        // Is it npm or yarn list?
        if (lastLine.startsWith("└─ ")) {
          step = 3; // yarn
        } else {
          step = 2; // npm
        }

        let prevEntryStartsAt = 0;
        let output = "";

        output += `<ul><li><p>${formatTreeNode(lines[0])}</p>`;

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];

          // npm prior to 7 was using +, -, and ` to build the tree connectors
          // npm 7 uses pseudo-graphic characters
          // yarn also uses pseudo-graphic characters, but differently
          let endOfTreeRegex;

          if (step === 2) {
            endOfTreeRegex = /-- |─┬ |── /; // npm
          } else {
            endOfTreeRegex = /├─ |└─ /; // yarn
          }

          const treeEndsAt = line.search(endOfTreeRegex);

          if (treeEndsAt >= 0) {
            const dependencyEntryStartsAt = treeEndsAt + 3; // 3 is the length of regex match
            const dependencyEntry = line.substring(dependencyEntryStartsAt);

            const dependency = formatTreeNode(dependencyEntry);

            let listItem = `<p>&nbsp;&nbsp;${dependency}</p>`;

            const hideLayer = treeEndsAt > 1;

            // Look ahead to see if this line should be expandable
            if (i < lines.length - 1) {
              const nextLineTreeEndsAt = lines[i + 1].search(endOfTreeRegex);

              if (nextLineTreeEndsAt > treeEndsAt) {
                listItem = `<p class="collapsible"><span class="bullet" onclick="toggleChildrenOf(this)">▶︎</span>&nbsp;${dependency}</p>`;
              }
            }

            if (dependencyEntryStartsAt > prevEntryStartsAt) {
              output += `<ul><li class="${
                hideLayer ? "hidden" : "shown"
              }">${listItem}`;
            } else if (dependencyEntryStartsAt < prevEntryStartsAt) {
              output += "</li>";
              let numLevelsUp =
                (prevEntryStartsAt - dependencyEntryStartsAt) / step;
              while (numLevelsUp-- > 0) {
                output += "</ul></li>";
              }
              output += `<li class="${
                hideLayer ? "hidden" : "shown"
              }">${listItem}`;
            } else {
              output += `</li><li class="${
                hideLayer ? "hidden" : "shown"
              }">${listItem}`;
            }

            prevEntryStartsAt = dependencyEntryStartsAt;
          }

          output += "\n";
        }

        // Close last item
        output += "</li>";

        // Now rewind to the top
        let numLevelsUp = prevEntryStartsAt / step;
        while (numLevelsUp-- > 0) {
          output += "</ul>";
        }

        return output;
      }
    </script>
  </body>
</html>
